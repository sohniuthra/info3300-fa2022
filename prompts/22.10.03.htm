<html>

<head>
  <title>INFO 3300 - October 3</title>

  <link href="https://fonts.googleapis.com/css?family=Lato:400,700|Raleway:400,700" rel="stylesheet">

  <link rel="stylesheet" type="text/css" href="../css/normalize.css">
  <link rel="stylesheet" type="text/css" href="../css/skeleton.css">
  <link rel="stylesheet" type="text/css" href="../css/custom-style.css">
  <link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/styles/default.min.css">
  <link rel="stylesheet" href="../css/hljs-base16.css">
  <script src="//cdnjs.cloudflare.com/ajax/libs/highlight.js/11.2.0/highlight.min.js"></script>

  <script src="https://d3js.org/d3.v7.min.js"></script>
  <script src="https://d3js.org/topojson.v3.min.js"></script>

  <style>
    .state {
      fill: lightgrey;
    }

    .outline {
      fill: none;
      stroke: black;
      stroke-width: 1px;
    }

    .graticule {
      fill: none;
      stroke: grey;
      stroke-width: 1px;
    }
  </style>

</head>

<body>
  <div class="container larger">
    <h3>Notes for October 3</h3>
    <p>
      If you have a moment, please complete <a href="https://forms.gle/fsGipJA3KTU8iygF6">this survey</a> to generate a
      dataset to use in class. Thanks.
    </p>
    <p>
      We have a new import at the top of the file: <a href="https://github.com/topojson/topojson">TopoJSON</a><br />
      TopoJSON provides a helpful framework for storing, loading, and displaying topographical data. Check out its <a
        href="https://github.com/topojson/topojson-specification">data specification</a>.
    </p>
    <p>
      More on <a href="https://github.com/d3/d3-geo">d3.geo</a> and its <a
        href="https://github.com/d3/d3-geo#azimuthal-projections">geographic projections</a>.
    </p>

    <h5>HTML for today:</h5>


    <svg id="choropleth" height="600" width="900" style="background: #445; margin-top:50px">

    </svg>

    <svg id="colorLegend" height="100" width="600" style="background: #fff; margin-top:30px">

    </svg>


    <!-- This block will be automatically filled with syntax-highlighted code from the script below -->
    <h5>Code for today:</h5>
    <pre>
    <code id="display1" class="hljs javascript">
    </code>
  </pre>


    <!--- Code for today's class --->
    <script id="notes1">

      const svg = d3.select("#choropleth");
      const width = svg.attr("width");
      const height = svg.attr("height");
      const margin = { top: 20, right: 20, bottom: 20, left: 20 };
      const mapWidth = width - margin.left - margin.right;
      const mapHeight = height - margin.top - margin.bottom;
      const map = svg.append("g")
        .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

      // 0. Let's explore a new way to use promises for data imports that might be a bit cleaner when importing lots of files

      //geoJSON - dense - (edge matrix)
      //topoJSON (newer) -> anything that can open topo can open geo - sparse (edge list)

      d3.json().then(function () {

        //everything
      })

      const testFunc = async function () {

        //everything (including d3.csv and other loads)

        const data = await d3.json("../datasets/us-smaller.json")
      }
      testFunc();

      // 1. An async function to load data and build the map

      const requestData = async function () {

        // 2. Draw a map of US using topoJSON
        // 2a. Import data as synchronous call to topoJSON data file
        // Care of Mike Bostock:
        //   "../datasets/us-smaller.json"

        var us = await d3.json("../datasets/us-smaller.json")
        var states = topojson.feature(us, us.objects.states);
        //mesh is an outline
        let statesMesh = topojson.mesh(us, us.objects.states);

        //fit size looks at the size of svg and size of data
        const projection = d3.geoAlbersUsa().fitSize([mapWidth, mapHeight], states);
        const path = d3.geoPath().projection(projection);

        // 2b. Pick out topographic features and build d3 helpers
        let states = map.selectAll("path.state").data(states.features)
          .join("path")
          .attr("class", "state")
          .attr("note", d => d.id)
          .attr("d", path)

        map.append("path").datum(statesMesh)
          .attr("class", "outline")
          .attr("d", path)

        // 2c. Draw states and outlines

        // 2d. Add a graticule (we did this after 2c, but it must go here)
        //      (Graticules are much more configurable, but we'll use the default for now)

        let graticule = d3.geoGraticule10();
        map.append("path").attr("class", "graticule").attr("d", path(graticule));




        // 3a. Import survey data as synchronous calls
        // "../datasets/us-state-names.tsv"
        // "../datasets/state-survey-responses-22.csv"
        const surveyData = await d3.csv("../datasets/state-survey-responses-22.csv", d3.autoType);



        // 3b. Generate the counts we will need
        let stateIdCounts = {} //stateID => count #
        let stateIdNames = {} //stateID => name of state
        surveyData.forEach(row => {
          stateIdCounts[row.state_code] = Number(row.total);
          stateIdNames[row.state_code] = row.state_name;
        });


        // 3c. Make a d3 color scale for frequency    
        const minMax = d3.extent(surveyData, d => Number(d.total));
        // const colorScale = d3.scaleSequential(d3.interpolateBuPu).domain(minMax);

        //breaks into chunks
        // const colorScale = d3.scaleQuantize().domain(minMax).range(["rgb(160, 210, 232", "rgb(111, 116, 210", "rgb(37, 92, 214", "rgb(41, 19, 177"])

        const colorScale = d3.scaleQuantile()
          .domain(Object.values(stateIdCounts)).range()

        // 3d. Recolor the states to make a choropleth map
        states.style("fill", d => colorScale(stateIdCounts[d.id]));



        // 3e. Use the extra legend code to draw a legend





        // 4. Add a tooltip that "sticks" below the state


        // // Stub code to draw the tooltip - we use an SVG element here
        // // You can use an absolute-positioned HTML element, but the positioning requires some more work
        // // Instead, we make something centered at (0,0) and then later use translate() to move it
        // //  (this is why the x position for the rect is -tooltipWidth/2.0  -- so it's centered on 0 )
        // let tooltip = map.append("g")
        //                  .attr("class","tooltip")
        //                  .attr("visibility","hidden");
        // tooltip.append("rect")
        //        .attr("fill", "black")
        //        .attr("opacity", 0.9)
        //        .attr("x", -tooltipWidth / 2.0)
        //        .attr("y", 0)
        //        .attr("width",tooltipWidth)
        //        .attr("height",tooltipHeight)
        // let txt = tooltip.append("text")
        //                  .attr("fill", "white")
        //                  .attr("text-anchor","middle")
        //                  .attr("alignment-baseline","hanging")
        //                  .attr("x", 0)
        //                  .attr("y", 2);
        // let txt2 = tooltip.append("text")
        //                  .attr("fill", "white")
        //                  .attr("text-anchor","middle")
        //                  .attr("alignment-baseline","hanging")
        //                  .attr("x", 0)
        //                  .attr("y", 22);




        function mouseEntersPlot() {
        }

        function mouseLeavesPlot() {
        }






        // END OF REQUESTDATA()
      }
      requestData();



    </script>







    <!--- calls the highlight library to fill the <pre> tag with code --->
    <script>

      function sanitize(s) {
        return s.replace("<br>", "\\n")
          .replace(/&/g, "&amp;")
          .replace(/</g, "&lt;")
          .replace(/>/g, "&gt;")
          .replace(/"/g, "&quot;")
          .replace(/'/g, "&#039;");
      }
      document.getElementById("display1").innerHTML = sanitize(document.getElementById("notes1").innerText);
      hljs.highlightAll();
    </script>


  </div>
</body>

</html>